// Generated by CoffeeScript 1.3.3
(function() {
  'use strict';

  var Cell, Life, requestAnimFrame;

  requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
    return window.setTimeout(callback, 1000 / 60);
  };

  Cell = (function() {

    function Cell(isAlive) {
      this.isAlive = isAlive;
    }

    Cell.prototype.aliveNeighbours = function(xMid, yMid) {
      var alive, x, xMax, xMin, y, yMax, yMin, _i, _j;
      xMin = xMid - 1;
      yMin = yMid - 1;
      xMax = xMid + 1;
      yMax = yMid + 1;
      alive = 0;
      for (x = _i = xMin; xMin <= xMax ? _i <= xMax : _i >= xMax; x = xMin <= xMax ? ++_i : --_i) {
        for (y = _j = yMin; yMin <= yMax ? _j <= yMax : _j >= yMax; y = yMin <= yMax ? ++_j : --_j) {
          if (x < 0) {
            x = Life.width - 1;
          }
          if (x === Life.width) {
            x = 0;
          }
          if (y < 0) {
            y = Life.height - 1;
          }
          if (y === Life.height) {
            y = 0;
          }
          if ((x !== xMid || y !== yMid) && Life.board[x][y].isAlive) {
            if (alive === 3) {
              return 4;
            } else {
              ++alive;
            }
          }
        }
      }
      return alive;
    };

    Cell.prototype.nextState = function(x, y) {
      var neighbours;
      neighbours = this.aliveNeighbours(x, y);
      return neighbours === 3 || (this.isAlive && neighbours === 2);
    };

    return Cell;

  })();

  Life = {
    init: function(options) {
      var x, y, _i, _j, _ref, _ref1;
      options || (options = {});
      this.canvas = (document.getElementsByTagName('canvas'))[0];
      this.ctx = this.canvas.getContext('2d');
      this.canvas.width = document.documentElement.clientWidth;
      this.canvas.height = document.documentElement.clientHeight;
      this.pixelSize = options.pixelSize || 1;
      this.width = Math.floor(this.canvas.width / this.pixelSize);
      this.height = Math.floor(this.canvas.height / this.pixelSize);
      this.board = [];
      for (x = _i = 0, _ref = window.screen.availWidth; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.board[x] = [];
        for (y = _j = 0, _ref1 = window.screen.availWidth; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          this.board[x][y] = new Cell(Math.floor(Math.random() * 2));
        }
      }
      this.setHandlers();
      return this.draw();
    },
    step: function() {
      var cell, newBoard, row, x, y, _i, _j, _k, _len, _ref, _ref1, _results;
      newBoard = [];
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        newBoard[x] = [];
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          newBoard[x][y] = new Cell(this.board[x][y].nextState(x, y));
        }
      }
      _results = [];
      for (x = _k = 0, _len = newBoard.length; _k < _len; x = ++_k) {
        row = newBoard[x];
        _results.push((function() {
          var _l, _len1, _results1;
          _results1 = [];
          for (y = _l = 0, _len1 = row.length; _l < _len1; y = ++_l) {
            cell = row[y];
            _results1.push(this.board[x][y] = cell);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    draw: function() {
      var canvasPixelWidth, imageData, imageDataColAlpha, pixelX, pixelY, x, xPixels, y, yPixels, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3,
        _this = this;
      requestAnimFrame(function() {
        return _this.draw();
      });
      imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      canvasPixelWidth = imageData.width * 4;
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        xPixels = x * this.pixelSize;
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          yPixels = y * this.pixelSize;
          for (pixelX = _k = 0, _ref2 = this.pixelSize; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; pixelX = 0 <= _ref2 ? ++_k : --_k) {
            imageDataColAlpha = (xPixels + pixelX) * 4 + 3;
            for (pixelY = _l = 0, _ref3 = this.pixelSize; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; pixelY = 0 <= _ref3 ? ++_l : --_l) {
              if (this.board[x][y].isAlive) {
                imageData.data[(yPixels + pixelY) * canvasPixelWidth + imageDataColAlpha] = 255;
              }
            }
          }
        }
      }
      this.ctx.putImageData(imageData, 0, 0);
      return this.step();
    },
    setHandlers: function() {
      var _this = this;
      return window.addEventListener('resize', function() {
        _this.canvas.width = document.documentElement.clientWidth;
        _this.canvas.height = document.documentElement.clientHeight;
        _this.width = Math.floor(_this.canvas.width / _this.pixelSize);
        return _this.height = Math.floor(_this.canvas.height / _this.pixelSize);
      });
    }
  };

  Life.init({
    pixelSize: 2
  });

}).call(this);
